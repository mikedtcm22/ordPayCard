<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SatSpray Membership Card</title>
    <style>
        /* All styles must be inline - no external CSS */
        body {
            margin: 0;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        
        .card-container {
            width: 400px;
            max-width: 90vw;
            background: white;
            border-radius: 16px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        
        .card-visual {
            width: 100%;
            height: 240px;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .card-info {
            padding: 24px;
        }
        
        .status-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 9999px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .status-active {
            background: #10b981;
            color: white;
        }
        
        .status-expired {
            background: #ef4444;
            color: white;
        }
        
        .balance-info {
            margin-top: 16px;
            font-size: 14px;
            color: #6b7280;
        }
        
        .balance-value {
            font-size: 24px;
            font-weight: 700;
            color: #111827;
            margin-top: 4px;
        }
    </style>
</head>
<body>
    <div class="card-container">
        <div class="card-visual" id="cardVisual">
            <!-- SVG will be inserted here by JavaScript -->
        </div>
        <div class="card-info">
            <div id="statusBadge" class="status-badge">Loading...</div>
            <div class="balance-info">
                <div>Current Balance</div>
                <div id="balanceDisplay" class="balance-value">-- sats</div>
            </div>
            <div style="margin-top: 8px; font-size: 12px; color: #9ca3af;">
                Decay Rate: <span id="decayRate">100</span> sats/block
            </div>
        </div>
    </div>

    <script>
        /**
         * SatSpray Membership Card - Recursive Inscription Template
         * 
         * MVP Phase (2.2.1b): Payment-aware inscriptions with trusted receipts
         * - Fetches child inscriptions (receipts) via recursive endpoints
         * - Trusts receipt amounts without blockchain verification
         * - Implements balance decay based on block height
         * - Deduplicates receipts by transaction ID
         * 
         * Future Phase (2.2.1c): Will add on-chain payment verification
         * - Parser library will validate OP_RETURN data in transactions
         * - Only payments with matching card ID in OP_RETURN will count
         * - Prevents all forms of payment forgery and reuse
         */
        
        // Configuration - These values are hardcoded into the inscription
        window.CARD_SCHEMA_VER = "1";
        window.DECAY_PER_BLOCK = 100; // Increased for Signet testing
        window.TREASURY_ADDR = "tb1q..."; // Will be set during creation
        
        // Embedded SVG assets
        const SVG_ACTIVE = '<svg viewBox="0 0 400 240" xmlns="http://www.w3.org/2000/svg"><defs><linearGradient id="activeGradient" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" style="stop-color:#10b981;stop-opacity:1" /><stop offset="100%" style="stop-color:#059669;stop-opacity:1" /></linearGradient><pattern id="circuitPattern" x="0" y="0" width="60" height="60" patternUnits="userSpaceOnUse"><circle cx="5" cy="5" r="2" fill="#34d399" opacity="0.3"/><circle cx="35" cy="5" r="2" fill="#34d399" opacity="0.3"/><circle cx="20" cy="20" r="2" fill="#34d399" opacity="0.3"/><circle cx="5" cy="35" r="2" fill="#34d399" opacity="0.3"/><circle cx="35" cy="35" r="2" fill="#34d399" opacity="0.3"/><path d="M5,5 L20,20 M20,20 L35,5 M20,20 L5,35 M20,20 L35,35" stroke="#34d399" stroke-width="0.5" opacity="0.2"/></pattern><filter id="glow"><feGaussianBlur stdDeviation="4" result="coloredBlur"/><feMerge><feMergeNode in="coloredBlur"/><feMergeNode in="SourceGraphic"/></feMerge></filter></defs><rect width="400" height="240" fill="url(#activeGradient)"/><rect width="400" height="240" fill="url(#circuitPattern)" opacity="0.5"/><ellipse cx="200" cy="120" rx="150" ry="80" fill="#34d399" opacity="0.2" filter="url(#glow)"/><g transform="translate(200, 120)"><circle cx="0" cy="0" r="50" fill="none" stroke="white" stroke-width="3" opacity="0.3"/><path d="M -15,-30 L -15,30 M -15,-25 L 5,-25 C 15,-25 20,-15 15,-5 C 20,5 15,15 5,15 L -15,15 M -15,5 L 5,5 M -20,-30 L -10,-30 M -20,30 L -10,30 M 0,-35 L 0,-25 M 5,-35 L 5,-25 M 0,25 L 0,35 M 5,25 L 5,35" stroke="white" stroke-width="4" fill="none" stroke-linecap="round" stroke-linejoin="round" filter="url(#glow)"/></g><text x="200" y="200" text-anchor="middle" font-family="Arial, sans-serif" font-size="20" font-weight="bold" fill="white" letter-spacing="3">ACTIVE</text><g opacity="0.3"><path d="M 20,20 L 40,20 L 20,40 Z" fill="white"/><path d="M 380,20 L 380,40 L 360,20 Z" fill="white"/><path d="M 20,220 L 20,200 L 40,220 Z" fill="white"/><path d="M 380,220 L 360,220 L 380,200 Z" fill="white"/></g></svg>';
        
        const SVG_EXPIRED = '<svg viewBox="0 0 400 240" xmlns="http://www.w3.org/2000/svg"><defs><linearGradient id="expiredGradient" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" style="stop-color:#ef4444;stop-opacity:1" /><stop offset="100%" style="stop-color:#dc2626;stop-opacity:1" /></linearGradient><pattern id="brokenCircuitPattern" x="0" y="0" width="60" height="60" patternUnits="userSpaceOnUse"><circle cx="5" cy="5" r="2" fill="#f87171" opacity="0.2"/><circle cx="35" cy="5" r="2" fill="#f87171" opacity="0.2"/><circle cx="20" cy="20" r="2" fill="#f87171" opacity="0.2"/><circle cx="5" cy="35" r="2" fill="#f87171" opacity="0.2"/><circle cx="35" cy="35" r="2" fill="#f87171" opacity="0.2"/><path d="M5,5 L10,10 M15,15 L20,20 M20,20 L25,15 M30,10 L35,5" stroke="#f87171" stroke-width="0.5" opacity="0.15" stroke-dasharray="2,2"/><path d="M20,20 L15,25 M10,30 L5,35 M20,20 L25,25 M30,30 L35,35" stroke="#f87171" stroke-width="0.5" opacity="0.15" stroke-dasharray="2,2"/></pattern><filter id="fade"><feGaussianBlur stdDeviation="2" result="coloredBlur"/><feMerge><feMergeNode in="coloredBlur"/><feMergeNode in="SourceGraphic"/></feMerge></filter></defs><rect width="400" height="240" fill="url(#expiredGradient)"/><rect width="400" height="240" fill="url(#brokenCircuitPattern)" opacity="0.5"/><ellipse cx="200" cy="120" rx="150" ry="80" fill="#f87171" opacity="0.1"/><g transform="translate(200, 120)" opacity="0.5"><path d="M 50,0 A 50,50 0 0,1 35.355,35.355" fill="none" stroke="white" stroke-width="3" opacity="0.3"/><path d="M -35.355,35.355 A 50,50 0 0,1 -50,0" fill="none" stroke="white" stroke-width="3" opacity="0.3"/><path d="M -35.355,-35.355 A 50,50 0 0,1 0,-50" fill="none" stroke="white" stroke-width="3" opacity="0.3"/><path d="M 35.355,-35.355 A 50,50 0 0,1 50,0" fill="none" stroke="white" stroke-width="3" opacity="0.3" transform="rotate(20)"/><path d="M -15,-30 L -15,30 M -15,-25 L 5,-25 C 15,-25 20,-15 15,-5 C 20,5 15,15 5,15 L -15,15 M -15,5 L 5,5 M -20,-30 L -10,-30 M -20,30 L -10,30 M 0,-35 L 0,-25 M 5,-35 L 5,-25 M 0,25 L 0,35 M 5,25 L 5,35" stroke="white" stroke-width="4" fill="none" stroke-linecap="round" stroke-linejoin="round" opacity="0.6" filter="url(#fade)"/></g><text x="200" y="200" text-anchor="middle" font-family="Arial, sans-serif" font-size="20" font-weight="bold" fill="white" letter-spacing="3">EXPIRED</text><line x1="50" y1="190" x2="350" y2="50" stroke="rgba(255,255,255,0.2)" stroke-width="2" stroke-dasharray="5,5"/><g opacity="0.2"><path d="M 20,20 L 30,20 M 35,20 L 40,20 L 20,40 M 20,35 L 20,30" fill="none" stroke="white" stroke-width="2"/><path d="M 380,20 L 380,30 M 380,35 L 380,40 L 360,20 M 365,20 L 370,20" fill="none" stroke="white" stroke-width="2"/><path d="M 20,220 L 20,210 M 20,205 L 20,200 L 40,220 M 35,220 L 30,220" fill="none" stroke="white" stroke-width="2"/><path d="M 380,220 L 370,220 M 365,220 L 360,220 L 380,200 M 380,205 L 380,210" fill="none" stroke="white" stroke-width="2"/></g></svg>';
        
        // Balance calculation and state management with recursive inscriptions (ES5 compatible)
        (function() {
            // Step 1: Get inscription ID from URL path
            function getInscriptionId() {
                var pathParts = window.location.pathname.split('/');
                var inscriptionId = pathParts[pathParts.length - 1];
                
                // Validate inscription ID format
                if (!/^[a-f0-9]{64}i\d+$/i.test(inscriptionId)) {
                    console.error('Invalid inscription ID format');
                    return null;
                }
                
                return inscriptionId;
            }
            
            // Store inscription ID globally
            window.INSCRIPTION_ID = getInscriptionId();
            
            // Step 2: Implement recursive data fetching
            
            // Wrapper for fetch with timeout
            function fetchWithTimeout(url, timeout) {
                timeout = timeout || 5000;
                
                return new Promise(function(resolve, reject) {
                    var timer = setTimeout(function() {
                        reject(new Error('Request timeout'));
                    }, timeout);
                    
                    fetch(url)
                        .then(function(response) {
                            clearTimeout(timer);
                            resolve(response);
                        })
                        .catch(function(error) {
                            clearTimeout(timer);
                            reject(error);
                        });
                });
            }
            
            // Fetch with retry logic for critical endpoints
            function fetchWithRetry(url, maxRetries) {
                maxRetries = maxRetries || 3;
                
                function attemptFetch(retryCount) {
                    return fetchWithTimeout(url).then(function(response) {
                        if (response.ok) {
                            return response;
                        }
                        
                        // Don't retry on 4xx errors
                        if (response.status >= 400 && response.status < 500) {
                            throw new Error('HTTP ' + response.status);
                        }
                        
                        // Retry on server errors
                        if (retryCount < maxRetries - 1) {
                            return new Promise(function(resolve) {
                                setTimeout(function() {
                                    resolve(attemptFetch(retryCount + 1));
                                }, Math.pow(2, retryCount) * 1000);
                            });
                        }
                        
                        throw new Error('HTTP ' + response.status);
                    }).catch(function(error) {
                        if (retryCount < maxRetries - 1) {
                            return new Promise(function(resolve) {
                                setTimeout(function() {
                                    resolve(attemptFetch(retryCount + 1));
                                }, Math.pow(2, retryCount) * 1000);
                            });
                        }
                        throw error;
                    });
                }
                
                return attemptFetch(0);
            }
            
            // Get current block height from ord
            function getCurrentBlockHeight() {
                return fetchWithRetry('/r/blockheight')
                    .then(function(response) {
                        return response.json();
                    })
                    .then(function(blockHeight) {
                        return blockHeight;
                    })
                    .catch(function(error) {
                        console.error('Error fetching block height:', error);
                        // Fallback to a reasonable estimate
                        return 850000;
                    });
            }
            
            // Validate receipt format and data
            // MVP: This validates receipt structure only - receipts are trusted
            // Phase 2.2.1c will add on-chain payment verification via parser library
            function isValidReceipt(receipt) {
                // Check required fields
                if (!receipt || typeof receipt !== 'object') return false;
                if (receipt.schema !== 'satspray.topup.v1') return false;
                if (receipt.parent !== window.INSCRIPTION_ID) return false;
                if (receipt.paid_to !== window.TREASURY_ADDR) return false;
                
                // Validate data types
                if (typeof receipt.amount !== 'number' || receipt.amount <= 0) return false;
                if (typeof receipt.block !== 'number' || receipt.block <= 0) return false;
                if (typeof receipt.txid !== 'string' || !/^[a-f0-9]{64}$/i.test(receipt.txid)) return false;
                
                return true;
            }
            
            // Get receipt inscriptions (child inscriptions)
            function getReceipts() {
                if (!window.INSCRIPTION_ID) {
                    console.error('No inscription ID available');
                    return Promise.resolve([]);
                }
                
                var receipts = [];
                
                function fetchPage(page) {
                    return fetchWithRetry('/r/children/' + window.INSCRIPTION_ID + '/inscriptions/' + page)
                        .then(function(response) {
                            return response.json();
                        })
                        .then(function(data) {
                            // Process each child inscription
                            var childPromises = [];
                            
                            for (var i = 0; i < data.ids.length; i++) {
                                var childId = data.ids[i];
                                
                                var childPromise = fetchWithTimeout('/r/content/' + childId)
                                    .then(function(contentResponse) {
                                        return contentResponse.text();
                                    })
                                    .then(function(receiptText) {
                                        try {
                                            var receipt = JSON.parse(receiptText);
                                            if (isValidReceipt(receipt)) {
                                                receipts.push(receipt);
                                            }
                                        } catch (err) {
                                            console.error('Error parsing receipt:', err);
                                        }
                                    })
                                    .catch(function(err) {
                                        console.error('Error fetching child content:', err);
                                    });
                                
                                childPromises.push(childPromise);
                            }
                            
                            return Promise.all(childPromises).then(function() {
                                if (data.more) {
                                    return fetchPage(page + 1);
                                }
                            });
                        })
                        .catch(function(error) {
                            console.error('Error fetching children page ' + page + ':', error);
                        });
                }
                
                return fetchPage(0)
                    .then(function() {
                        return receipts;
                    })
                    .catch(function(error) {
                        console.error('Error fetching receipts:', error);
                        return [];
                    });
            }
            
            // Step 3: Update balance calculation to use real block height
            function calculateBalance() {
                return Promise.all([getReceipts(), getCurrentBlockHeight()])
                    .then(function(results) {
                        var receipts = results[0];
                        var currentBlock = results[1];
                        
                        // Deduplicate receipts by transaction ID
                        // MVP: Prevents counting same transaction multiple times
                        // Phase 2.2.1c will add parser validation with OP_RETURN checks
                        var uniqueTxids = {};
                        var deduplicatedReceipts = [];
                        
                        for (var i = 0; i < receipts.length; i++) {
                            var receipt = receipts[i];
                            if (!uniqueTxids[receipt.txid]) {
                                uniqueTxids[receipt.txid] = true;
                                deduplicatedReceipts.push(receipt);
                            }
                        }
                        
                        if (receipts.length > deduplicatedReceipts.length) {
                            console.log('Deduplication: ' + receipts.length + ' receipts reduced to ' + 
                                       deduplicatedReceipts.length + ' unique transactions');
                        }
                        
                        // Sort deduplicated receipts by block height (oldest first)
                        var validReceipts = deduplicatedReceipts.sort(function(a, b) {
                            return a.block - b.block;
                        });
                        
                        // Calculate balance with proper decay logic
                        var totalBalance = 0;
                        
                        for (var i = 0; i < validReceipts.length; i++) {
                            var receipt = validReceipts[i];
                            
                            // Calculate decay from receipt block to current
                            var blocksSinceReceipt = currentBlock - receipt.block;
                            var decayAmount = blocksSinceReceipt * window.DECAY_PER_BLOCK;
                            
                            // Add receipt amount minus decay
                            var remainingValue = Math.max(0, receipt.amount - decayAmount);
                            totalBalance += remainingValue;
                            
                            console.log('Receipt: ' + receipt.amount + ' sats at block ' + receipt.block + ', remaining: ' + remainingValue);
                        }
                        
                        return Math.max(0, totalBalance);
                    });
            }
            
            // Step 4: Update UI based on current balance (async)
            function updateCardDisplay() {
                var statusBadge = document.getElementById('statusBadge');
                var balanceDisplay = document.getElementById('balanceDisplay');
                var cardVisual = document.getElementById('cardVisual');
                var decayRateElement = document.getElementById('decayRate');
                
                // Show loading state
                statusBadge.textContent = 'Loading...';
                balanceDisplay.textContent = '-- sats';
                
                return calculateBalance()
                    .then(function(balance) {
                        var isActive = balance > 0;
                        
                        // Update visual
                        cardVisual.innerHTML = isActive ? SVG_ACTIVE : SVG_EXPIRED;
                        
                        // Update status badge
                        statusBadge.textContent = isActive ? 'Active' : 'Expired';
                        statusBadge.className = 'status-badge ' + (isActive ? 'status-active' : 'status-expired');
                        
                        // Update balance display
                        balanceDisplay.textContent = balance.toLocaleString() + ' sats';
                        
                        // Calculate blocks remaining
                        var blocksRemaining = Math.floor(balance / window.DECAY_PER_BLOCK);
                        
                        // Update decay rate display
                        if (decayRateElement) {
                            decayRateElement.textContent = window.DECAY_PER_BLOCK;
                        }
                        
                        return {
                            balance: balance,
                            blocksRemaining: blocksRemaining,
                            status: isActive ? 'ACTIVE' : 'EXPIRED',
                            inscriptionId: window.INSCRIPTION_ID
                        };
                    })
                    .catch(function(error) {
                        console.error('Error updating display:', error);
                        statusBadge.textContent = 'Error';
                        statusBadge.className = 'status-badge status-expired';
                        return {
                            balance: 0,
                            blocksRemaining: 0,
                            status: 'ERROR',
                            error: error.message
                        };
                    });
            }
            
            // Expose cardStatus function for external queries
            window.cardStatus = function() {
                return updateCardDisplay();
            };
            
            // Step 5: Initialize on load with async operations
            window.addEventListener('load', function() {
                // Initial update
                updateCardDisplay().then(function(status) {
                    console.log('Card initialized:', status);
                });
                
                // Set up periodic updates (every 30 seconds)
                setInterval(function() {
                    updateCardDisplay().then(function(status) {
                        console.log('Card updated:', status);
                    });
                }, 30000);
            });
        })();
    </script>
</body>
</html>