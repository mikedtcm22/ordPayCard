<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Embers Registration-Aware NFT (Stub)</title>
  <style>
    body { margin:0; background:#111; color:#eee; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; display:flex; align-items:center; justify-content:center; min-height:100vh; }
    .wrap { width: 480px; max-width: 96vw; background:#1b1b1b; border-radius:12px; overflow:hidden; box-shadow:0 8px 32px rgba(0,0,0,0.45); }
    .media { width:100%; height: 320px; display:flex; align-items:center; justify-content:center; background:#0d0d0d; position:relative; }
    .status { padding: 16px 20px; font-size: 14px; color:#bbb; display:flex; align-items:center; justify-content:space-between; }
    .badge { padding:4px 10px; border-radius:999px; font-weight:700; font-size:12px; letter-spacing:0.4px; text-transform:uppercase; }
    .active { background:#10b981; color:#082c22; }
    .unreg { background:#f59e0b; color:#1b1202; }
    .wm { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; color:rgba(255,255,255,0.12); font-weight:900; font-size:48px; letter-spacing:6px; text-transform:uppercase; }
    .ph { width:100%; height:100%; display:flex; align-items:center; justify-content:center; color:#666; }
    img { max-width:100%; max-height:100%; display:block; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="media" id="media">
      <div class="ph" id="ph">Artwork</div>
      <div class="wm" id="wm">Unregistered</div>
    </div>
    <div class="status">
      <div>Embers v0 stub • <span id="id">INSCRIPTION_ID</span> • Paid: <span id="paid">0 sats</span></div>
      <div class="badge unreg" id="badge">Not Registered</div>
    </div>
  </div>

  <script>
    // Replace INSCRIPTION_ID at creation time if desired
    (function () {
      // Phase-0 default: embed image via data URI (placeholder small PNG)
      // Replace DATA_URI_IMAGE below during actual build/inscription
      var EMBED_DATA_URI = window.EMBED_DATA_URI || 'data:image/svg+xml;utf8,' + encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 600 400"><defs><linearGradient id="g" x1="0" y1="0" x2="1" y2="1"><stop offset="0" stop-color="#0ea5e9"/><stop offset="1" stop-color="#22d3ee"/></linearGradient></defs><rect width="600" height="400" fill="url(#g)"/><text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" font-family="Arial" font-size="42" fill="#ffffff" opacity="0.8">Embers</text></svg>');

      function parseSelfId() {
        try {
          // Attempt 1: parse from this frame's location (works if not srcdoc)
          var p = (location && location.pathname) ? location.pathname : '';
          var m = p.match(/\/(?:content|inscription)\/([a-f0-9]{64}i\d+)/);
          if (m && m[1]) return m[1];
          // Attempt 2: parse from referrer (ord viewer page URL contains the id)
          var r = (document && document.referrer) ? document.referrer : '';
          var mr = r.match(/\/(?:content|inscription)\/([a-f0-9]{64}i\d+)/);
          if (mr && mr[1]) return mr[1];
          return null;
        } catch (e) { return null; }
      }

      function timeoutFetch(url, ms) {
        return new Promise(function(resolve, reject){
          var t = setTimeout(function(){ reject(new Error('timeout')); }, ms);
          fetch(url).then(function(r){ clearTimeout(t); resolve(r); }, function(err){ clearTimeout(t); reject(err); });
        });
      }

      async function getChildren() {
        // Try ord recursive endpoints; fallback to window.CHILDREN stub
        var hinted = (window.CHILDREN || []);
        try {
          var selfId = parseSelfId();
          if (!selfId) return hinted;
          // Try both variants depending on ord version
          var urls = [
            '/r/children/' + selfId + '/inscriptions',
            '/r/children/' + selfId
          ];
          var ids = [];
          for (var i = 0; i < urls.length; i++) {
            try {
              var res = await timeoutFetch(urls[i], 1500);
              if (!res.ok) continue;
              var txt = await res.text();
              var data;
              try { data = JSON.parse(txt); } catch(_) { data = null; }
              if (data && Array.isArray(data.children)) {
                // Newer ord returns objects; map to id when present
                ids = data.children.map(function(c){ return (c && typeof c === 'object') ? c.id : c; }).filter(Boolean);
                break;
              }
              if (data && Array.isArray(data.ids)) { ids = data.ids; break; }
            } catch (_) { /* continue */ }
          }
          if (ids.length === 0) return hinted;
          // Load each child's content and parse JSON if possible
          var out = [];
          for (var j = 0; j < ids.length; j++) {
            try {
              var cRes = await timeoutFetch('/content/' + ids[j], 1500);
              if (!cRes.ok) continue;
              var text = await cRes.text();
              try { var json = JSON.parse(text); out.push(json); } catch(_) {}
            } catch(_) {}
          }
          return out.length ? out : hinted;
        } catch (e) {
          return hinted;
        }
      }

      function findRegistration(children) {
        // Phase-2: Deduplicate by feeTxid before processing
        var feeTxids = [];
        var registrations = [];
        
        // Extract feeTxids and collect valid registrations
        for (var i = 0; i < children.length; i++) {
          var c = children[i];
          if (c && c.schema === 'buyer_registration.v1') {
            registrations.push(c);
            if (c.feeTxid) {
              feeTxids.push(c.feeTxid);
            }
          }
        }
        
        // Deduplicate feeTxids using EmbersCore.dedupe if available
        var uniqueTxids = feeTxids;
        if (window.EmbersCore && typeof window.EmbersCore.dedupe === 'function') {
          try {
            var deduped = window.EmbersCore.dedupe(feeTxids);
            if (deduped && Array.isArray(deduped)) {
              uniqueTxids = deduped;
            }
          } catch (e) {
            // Fall back to original list if dedupe fails
            uniqueTxids = feeTxids;
          }
        }
        
        // Return first registration with unique feeTxid (order-preserving)
        for (var j = 0; j < uniqueTxids.length; j++) {
          var txid = uniqueTxids[j];
          for (var k = 0; k < registrations.length; k++) {
            var reg = registrations[k];
            if (reg.feeTxid === txid) {
              return reg;
            }
          }
        }
        
        // Fallback to first valid registration without feeTxid
        for (var l = 0; l < registrations.length; l++) {
          var fallback = registrations[l];
          if (!fallback.feeTxid) return fallback;
        }
        
        return null;
      }

      function render(isRegistered, amountSats) {
        var media = document.getElementById('media');
        var badge = document.getElementById('badge');
        var wm = document.getElementById('wm');
        var ph = document.getElementById('ph');
        var paid = document.getElementById('paid');

        // Clear existing image
        var imgs = media.getElementsByTagName('img');
        if (imgs[0]) media.removeChild(imgs[0]);

        if (paid) {
          try {
            var v = (amountSats === undefined || amountSats === null) ? '0' : String(amountSats);
            paid.textContent = v + ' sats';
          } catch (_) { paid.textContent = '0 sats'; }
        }

        if (isRegistered) {
          var img = new Image();
          img.src = EMBED_DATA_URI; // embedded path in Phase-0
          media.appendChild(img);
          badge.className = 'badge active';
          badge.textContent = 'Active';
          wm.style.display = 'none';
          if (ph) ph.style.display = 'none';
        } else {
          badge.className = 'badge unreg';
          badge.textContent = 'Not Registered';
          wm.style.display = 'flex';
          if (ph) ph.style.display = 'flex';
        }
      }

      async function verifyPaymentAmount(nftId) {
        try {
          if (window.EmbersCore && typeof window.EmbersCore.verifyPayment === 'function') {
            // Minimal call; real arguments wired in later phases
            var amt = await window.EmbersCore.verifyPayment('', '', 0n, nftId || '', { currentBlock: 0, network: 'regtest' });
            if (typeof amt === 'bigint') return amt;
            var n = Number(amt || 0);
            return BigInt(isNaN(n) ? 0 : n);
          }
        } catch (_) { /* fall through */ }
        return 0n;
      }

      function attachDebugInfo(inputs, outputs) {
        // B3: Developer debug flag implementation
        try {
          if (window.DEBUG === 1 || window.DEBUG === true) {
            // Filter out PII fields from inputs
            var sanitizedInputs = {};
            // Always include selfId even if null
            if (inputs) {
              sanitizedInputs.selfId = inputs.selfId || null;
            }
            if (inputs && inputs.children && Array.isArray(inputs.children)) {
              // Remove PII fields like buyer_email, buyer_name from children
              sanitizedInputs.children = inputs.children.map(function(child) {
                if (!child || typeof child !== 'object') return child;
                var sanitized = {};
                for (var key in child) {
                  if (key && typeof key === 'string' &&
                      key.indexOf('buyer_email') === -1 && 
                      key.indexOf('buyer_name') === -1 &&
                      key.indexOf('email') === -1 &&
                      key.indexOf('name') === -1) {
                    sanitized[key] = child[key];
                  }
                }
                return sanitized;
              });
            }

            // Convert BigInt to string and remove PII from outputs
            var sanitizedOutputs = {};
            if (outputs) {
              for (var outputKey in outputs) {
                var value = outputs[outputKey];
                if (typeof value === 'bigint') {
                  sanitizedOutputs[outputKey] = value.toString();
                } else if (value && typeof value === 'object') {
                  // Sanitize object fields to remove PII
                  var sanitizedValue = {};
                  for (var key in value) {
                    if (key && typeof key === 'string' &&
                        key.indexOf('buyer_email') === -1 && 
                        key.indexOf('buyer_name') === -1 &&
                        key.indexOf('email') === -1 &&
                        key.indexOf('name') === -1) {
                      sanitizedValue[key] = value[key];
                    }
                  }
                  sanitizedOutputs[outputKey] = sanitizedValue;
                } else {
                  sanitizedOutputs[outputKey] = value;
                }
              }
            }

            window.__debug = {
              lastInputs: sanitizedInputs,
              lastOutputs: sanitizedOutputs,
              timestamp: new Date().toISOString()
            };

            // Include provenance diagnostics if available
            if (window.PROVENANCE_DIAGNOSTICS && typeof window.PROVENANCE_DIAGNOSTICS === 'object') {
              window.__debug.provenance = window.PROVENANCE_DIAGNOSTICS;
            }
          } else if (window.DEBUG === 0 || window.DEBUG === false) {
            // Remove debug object when DEBUG is explicitly false
            if (window.__debug) {
              delete window.__debug;
            }
          }
        } catch (e) {
          // Silent failure in debug attachment
        }
      }

      async function checkRegistration() {
        var selfId = parseSelfId();
        // Best-effort children load (legacy receipts), non-blocking for B1 path
        var children = await getChildren();
        var reg = findRegistration(children);
        var paid = await verifyPaymentAmount(selfId);
        var isRegistered = (typeof paid === 'bigint' ? paid > 0n : Number(paid) > 0) || !!reg;
        
        var inputs = { selfId: selfId, children: children };
        var outputs = { isRegistered: isRegistered, lastRegistration: reg, paidSats: paid };
        
        // Attach debug info if enabled
        attachDebugInfo(inputs, outputs);
        
        render(isRegistered, paid);
        return outputs;
      }

      window.registrationStatus = checkRegistration;
      window.addEventListener('load', checkRegistration);
    })();
  </script>
</body>
</html>

